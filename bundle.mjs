class Cache extends Map{constructor(e,t=0){super(),this.maxSize=e,this.defaultTimeToLive=t,this._nextWriteIndex=0,this._keyList=Array(e),this._timers=new Map}set(e,t,s=this.defaultTimeToLive){let a=this._nextWriteIndex;this.delete(this._keyList[a]),this._keyList[a]=e,this._nextWriteIndex=(a+1)%this.maxSize,this._timers.has(e)&&clearTimeout(this._timers.get(e)),super.set(e,t),s&&this._timers.set(e,setTimeout((()=>this.delete(e)),s))}delete(e){return this._timers.has(e)&&clearTimeout(this._timers.get(e)),this._timers.delete(e),super.delete(e)}clear(e=this.maxSize){this.maxSize=e,this._keyList=Array(e),this._nextWriteIndex=0,super.clear();for(const e of this._timers.values())clearTimeout(e);this._timers.clear()}}class StorageBase{constructor({name:e,debug:t=!1}){const s=new Cache(1e3);Object.assign(this,{name:e,debug:t,serializer:s})}async list(){return this.listInternal(await this.cache(""))}async get(e){return this.getInternal(this.path(e),await this.cache(e))}async delete(e){return this.deleteInternal(this.path(e),await this.cache(e))}async put(e,t){return this.putInternal(this.path(e),t,await this.cache(e))}log(...e){this.debug&&console.log(this.name,...e)}cache(e){const{serializer:t,ready:s}=this;let a=t.get(e)||s;return a=a.then((e=>e)),t.set(e,a),a}}const{Response:e,URL:t}=globalThis;class StorageCache extends StorageBase{constructor(...e){super(...e),this.stripper=new RegExp(`^/${this.name}/`),this.ready=caches.open(this.name).then((async e=>{const t=await navigator.storage.persist();return console.log(`Storage ${this.name} ${t?"is":"is not"} separate from browser-clearing.`),e}))}async listInternal(e){return(await e.keys()||[]).map((e=>this.tag(e.url)))}async getInternal(e,t){const s=await t.match(e);return s?.json()}deleteInternal(e,t){return t.delete(e)}putInternal(t,s,a){return a.put(t,e.json(s))}path(e){return`/${this.name}/${e}`}tag(e){return new t(e).pathname.replace(this.stripper,"")}destroy(){return caches.delete(this.name)}}export{StorageCache as StorageLocal};
