class Cache extends Map{constructor(e,t=0){super(),this.maxSize=e,this.defaultTimeToLive=t,this._nextWriteIndex=0,this._keyList=Array(e),this._timers=new Map}set(e,t,s=this.defaultTimeToLive){let i=this._nextWriteIndex;this.delete(this._keyList[i]),this._keyList[i]=e,this._nextWriteIndex=(i+1)%this.maxSize,this._timers.has(e)&&clearTimeout(this._timers.get(e)),super.set(e,t),s&&this._timers.set(e,setTimeout((()=>this.delete(e)),s))}delete(e){return this._timers.has(e)&&clearTimeout(this._timers.get(e)),this._timers.delete(e),super.delete(e)}clear(e=this.maxSize){this.maxSize=e,this._keyList=Array(e),this._nextWriteIndex=0,super.clear();for(const e of this._timers.values())clearTimeout(e);this._timers.clear()}}const{Response:e,URL:t}=globalThis;class StorageCache{static version=3;constructor({name:e,debug:t=!1}){const s=new RegExp("^/"+e),i=new Cache(1e3),r=caches.open(e);Object.assign(this,{name:e,debug:t,stripper:s,serializer:i,storage:r,queue:Promise.resolve()})}async list(){const e=e=>{const s=new t(e.url);return this.tag(s.pathname.replace(this.stripper,"")+s.search+s.hash)};return this.cache("").then((async t=>{this.url("");return(await t.keys()||[]).map(e)}))}get(e){return this.cacheGet(e).then((e=>e?.json()))}delete(e){return this.cache(e).then((t=>t.delete(this.url(e))))}put(t,s){const i=this.url(t);return this.cache(t).then((t=>t.put(i,e.json(s))))}log(...e){this.debug&&console.log(this.name,...e)}url(e){return e}tag(e){return e}cacheGet(e){return this.cache(e).then((t=>t.match(this.url(e))))}cache(e){const{storage:t,serializer:s}=this;let i=s.get(e)||Promise.resolve();return i=i.then((()=>t)),s.set(e,i),i}}export{StorageCache as StorageLocal};
